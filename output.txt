==== FILE: scaffold_with_navigation.dart ====
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'navigation_item.dart';

class ScaffoldWithNavigation extends StatelessWidget {
  const ScaffoldWithNavigation({
    super.key,
    required this.navigationShell,
  });

  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context) {
    void onDestinationSelected(int index) {
      navigationShell.goBranch(
        index,
        initialLocation: index == navigationShell.currentIndex,
      );
    }

    return LayoutBuilder(
      
      builder: (context, constraints) {
        return _ScaffoldWithNavigationBar(
          navigationShell: navigationShell,
          onDestinationSelected: onDestinationSelected,
        );
      },
    );
  }
}

class _ScaffoldWithNavigationBar extends StatelessWidget {
  const _ScaffoldWithNavigationBar({
    required this.navigationShell,
    required this.onDestinationSelected,
  });

  final StatefulNavigationShell navigationShell;
  final void Function(int)? onDestinationSelected;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: navigationShell,
      bottomNavigationBar: NavigationBar(
        selectedIndex: navigationShell.currentIndex,
        onDestinationSelected: onDestinationSelected,
        destinations: [
          for (final item in NavigationItem.values)
            NavigationDestination(
              icon: Icon(item.iconData),
              label: item.label,
            ),
        ],
      ),
    );
  }
}

==== FILE: navigation_item.dart ====
import 'package:flutter/material.dart';

enum NavigationItem {
  transcriptions(iconData: Icons.article, label: '一覧'),
  transcript(iconData: Icons.upload, label: '文字起こし'),
  settings(iconData: Icons.settings, label: '設定'),
  ;

  const NavigationItem({required this.iconData, required this.label});
  final IconData iconData;
  final String label;
}

==== FILE: auth_provider.dart ====
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

part 'auth_provider.g.dart';

@Riverpod(keepAlive: true)
Future<bool> isSignedIn(IsSignedInRef ref) {
  return ref
      .watch(supabaseKakiokosyUserProvider.future)
      .then((user) => user != null);
}

@Riverpod(keepAlive: true)
Stream<User?> supabaseKakiokosyUser(SupabaseKakiokosyUserRef ref) {
  return Supabase.instance.client.auth.onAuthStateChange
      .asyncMap((event) async {
    final session = event.session;
    if (session == null) {
      return null; //ログアウト状態
    }

    return session.user;
  });
}

==== FILE: auth_repository.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$authRepositoryHash() => r'827d48289fca9ff7300a551270d89129c3b7693f';

/// See also [authRepository].
@ProviderFor(authRepository)
final authRepositoryProvider = AutoDisposeProvider<AuthRepository>.internal(
  authRepository,
  name: r'authRepositoryProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$authRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef AuthRepositoryRef = AutoDisposeProviderRef<AuthRepository>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: auth_provider.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$isSignedInHash() => r'b5095c1ee0924431932ba17a753dcbbe2d1411cd';

/// See also [isSignedIn].
@ProviderFor(isSignedIn)
final isSignedInProvider = FutureProvider<bool>.internal(
  isSignedIn,
  name: r'isSignedInProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$isSignedInHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef IsSignedInRef = FutureProviderRef<bool>;
String _$supabaseKakiokosyUserHash() =>
    r'dafca0bb57758a2a5c19334b06763a5631685cc2';

/// See also [supabaseKakiokosyUser].
@ProviderFor(supabaseKakiokosyUser)
final supabaseKakiokosyUserProvider = StreamProvider<User?>.internal(
  supabaseKakiokosyUser,
  name: r'supabaseKakiokosyUserProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$supabaseKakiokosyUserHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef SupabaseKakiokosyUserRef = StreamProviderRef<User?>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: auth_repository.dart ====
import 'package:flutter/foundation.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:nottaalternative/core/authentication/model/user_model.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

part 'auth_repository.g.dart';

@riverpod
AuthRepository authRepository(AuthRepositoryRef ref) => AuthRepository();

class AuthRepository {
  final supabase = Supabase.instance.client;

  static var webClientId = dotenv.env['WEB_CLIENT_ID'];

  static var iosClientId = dotenv.env['IOS_CLIENT_ID'];

  Future<void> signOut() => supabase.auth.signOut();

  Future<AuthResponse> signInWithGoogle() async {
    final GoogleSignIn googleSignIn = GoogleSignIn(
      clientId: iosClientId,
      serverClientId: webClientId,
    );
    final googleUser = await googleSignIn.signIn();
    final googleAuth = await googleUser!.authentication;
    final accessToken = googleAuth.accessToken;
    final idToken = googleAuth.idToken;
    if (accessToken == null) {
      throw 'No Access Token found.';
    }
    if (idToken == null) {
      throw 'No ID Token found.';
    }

    // supabaseでのユーザー認証
    return supabase.auth.signInWithIdToken(
        provider: OAuthProvider.google,
        idToken: idToken,
        accessToken: accessToken);
  }

  // ここでユーザーオブジェクトを返却したほうが良いかどうかはわからん
  Future<void> signUpWithGoogle() async {
    try {
      final AuthResponse response = await signInWithGoogle();
      if (response.user == null) {
        throw 'supabase認証失敗';
      }
      KakiokosyUser? kakiokosyUser = await getUser(id: response.user!.id);
      // ユーザテーブルが作成されているかどうかで場合分けが必要だと思った。
      if (kakiokosyUser == null) {
        kakiokosyUser = await _createUser(id: response.user!.id);
      }
    } catch (e) {
      debugPrint('会員登録処理に失敗: $e');
    }
  }

  Future<KakiokosyUser?> getUser({required String id}) async {
    try {
      debugPrint('$idのユーザーを取得');
      final user = KakiokosyUser(id: id);
      final response =
          await supabase.from('users').select().eq('id', user.id).single();

      return KakiokosyUser.fromJson(response);
    } catch (e) {
      debugPrint('ユーザー取得処理に失敗: $e');
      return null;
    }
  }

  Future<KakiokosyUser?> _createUser({required String id}) async {
    try {
      debugPrint('$idに対するユーザー作成処理');
      final newUser = KakiokosyUser(id: id);
      final response = await supabase
          .from('users')
          .insert(newUser.toJson())
          .select()
          .single();
      debugPrint('$responseのユーザー作成処理完了');
      return KakiokosyUser.fromJson(response);
    } catch (e) {
      debugPrint('ユーザー新規作成処理に失敗: $e');
      return null;
    }
  }
}

==== FILE: user_model.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$KakiokosyUserImpl _$$KakiokosyUserImplFromJson(Map<String, dynamic> json) =>
    _$KakiokosyUserImpl(
      id: json['id'] as String,
      transcript_minute: (json['transcript_minute'] as num?)?.toInt() ?? 0,
      subscription_id: (json['subscription_id'] as num?)?.toInt() ?? 0,
    );

Map<String, dynamic> _$$KakiokosyUserImplToJson(_$KakiokosyUserImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'transcript_minute': instance.transcript_minute,
      'subscription_id': instance.subscription_id,
    };

==== FILE: user_model.dart ====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'user_model.freezed.dart';
part 'user_model.g.dart';

@freezed
class KakiokosyUser with _$KakiokosyUser {
  const factory KakiokosyUser({
    required String id, //primaryKey
    @Default(0) int transcript_minute, //その月に何分間、文字起こししたか
    @Default(0) int subscription_id, // defaultは0(0はサブスク無し)
  }) = _KakiokosyUser;

  factory KakiokosyUser.fromJson(Map<String, dynamic> json) =>
      _$KakiokosyUserFromJson(json);
}

==== FILE: user_model.freezed.dart ====
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'user_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

KakiokosyUser _$KakiokosyUserFromJson(Map<String, dynamic> json) {
  return _KakiokosyUser.fromJson(json);
}

/// @nodoc
mixin _$KakiokosyUser {
  String get id => throw _privateConstructorUsedError; //primaryKey
  int get transcript_minute =>
      throw _privateConstructorUsedError; //その月に何分間、文字起こししたか
  int get subscription_id => throw _privateConstructorUsedError;

  /// Serializes this KakiokosyUser to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of KakiokosyUser
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $KakiokosyUserCopyWith<KakiokosyUser> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $KakiokosyUserCopyWith<$Res> {
  factory $KakiokosyUserCopyWith(
          KakiokosyUser value, $Res Function(KakiokosyUser) then) =
      _$KakiokosyUserCopyWithImpl<$Res, KakiokosyUser>;
  @useResult
  $Res call({String id, int transcript_minute, int subscription_id});
}

/// @nodoc
class _$KakiokosyUserCopyWithImpl<$Res, $Val extends KakiokosyUser>
    implements $KakiokosyUserCopyWith<$Res> {
  _$KakiokosyUserCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of KakiokosyUser
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? transcript_minute = null,
    Object? subscription_id = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      transcript_minute: null == transcript_minute
          ? _value.transcript_minute
          : transcript_minute // ignore: cast_nullable_to_non_nullable
              as int,
      subscription_id: null == subscription_id
          ? _value.subscription_id
          : subscription_id // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$KakiokosyUserImplCopyWith<$Res>
    implements $KakiokosyUserCopyWith<$Res> {
  factory _$$KakiokosyUserImplCopyWith(
          _$KakiokosyUserImpl value, $Res Function(_$KakiokosyUserImpl) then) =
      __$$KakiokosyUserImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, int transcript_minute, int subscription_id});
}

/// @nodoc
class __$$KakiokosyUserImplCopyWithImpl<$Res>
    extends _$KakiokosyUserCopyWithImpl<$Res, _$KakiokosyUserImpl>
    implements _$$KakiokosyUserImplCopyWith<$Res> {
  __$$KakiokosyUserImplCopyWithImpl(
      _$KakiokosyUserImpl _value, $Res Function(_$KakiokosyUserImpl) _then)
      : super(_value, _then);

  /// Create a copy of KakiokosyUser
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? transcript_minute = null,
    Object? subscription_id = null,
  }) {
    return _then(_$KakiokosyUserImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      transcript_minute: null == transcript_minute
          ? _value.transcript_minute
          : transcript_minute // ignore: cast_nullable_to_non_nullable
              as int,
      subscription_id: null == subscription_id
          ? _value.subscription_id
          : subscription_id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$KakiokosyUserImpl implements _KakiokosyUser {
  const _$KakiokosyUserImpl(
      {required this.id, this.transcript_minute = 0, this.subscription_id = 0});

  factory _$KakiokosyUserImpl.fromJson(Map<String, dynamic> json) =>
      _$$KakiokosyUserImplFromJson(json);

  @override
  final String id;
//primaryKey
  @override
  @JsonKey()
  final int transcript_minute;
//その月に何分間、文字起こししたか
  @override
  @JsonKey()
  final int subscription_id;

  @override
  String toString() {
    return 'KakiokosyUser(id: $id, transcript_minute: $transcript_minute, subscription_id: $subscription_id)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$KakiokosyUserImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.transcript_minute, transcript_minute) ||
                other.transcript_minute == transcript_minute) &&
            (identical(other.subscription_id, subscription_id) ||
                other.subscription_id == subscription_id));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, transcript_minute, subscription_id);

  /// Create a copy of KakiokosyUser
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$KakiokosyUserImplCopyWith<_$KakiokosyUserImpl> get copyWith =>
      __$$KakiokosyUserImplCopyWithImpl<_$KakiokosyUserImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$KakiokosyUserImplToJson(
      this,
    );
  }
}

abstract class _KakiokosyUser implements KakiokosyUser {
  const factory _KakiokosyUser(
      {required final String id,
      final int transcript_minute,
      final int subscription_id}) = _$KakiokosyUserImpl;

  factory _KakiokosyUser.fromJson(Map<String, dynamic> json) =
      _$KakiokosyUserImpl.fromJson;

  @override
  String get id; //primaryKey
  @override
  int get transcript_minute; //その月に何分間、文字起こししたか
  @override
  int get subscription_id;

  /// Create a copy of KakiokosyUser
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$KakiokosyUserImplCopyWith<_$KakiokosyUserImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

==== FILE: app.dart ====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:nottaalternative/router/router.dart';

class App extends ConsumerWidget {
  const App({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(routerProvider);
    const Color backgroundColor = Color(0xFFEEF0F8);

    return MaterialApp.router(
        routerConfig: router,
        title: 'kakiokosy',
        theme: ThemeData(
          textTheme: GoogleFonts.notoSansJpTextTheme(
            Theme.of(context).textTheme,
          ),
          useMaterial3: true,
          colorScheme: ColorScheme.fromSeed(
            seedColor: Colors.blue,
            brightness: Brightness.light,
          ),
          scaffoldBackgroundColor: backgroundColor,
          appBarTheme: const AppBarTheme(
            backgroundColor: backgroundColor,
            elevation: 0,
          ),
          dialogBackgroundColor: backgroundColor,
          canvasColor: backgroundColor,
          dividerColor: Colors.transparent,
          popupMenuTheme: const PopupMenuThemeData(color: backgroundColor),
          bottomAppBarTheme: const BottomAppBarTheme(color: backgroundColor),
          bottomSheetTheme: const BottomSheetThemeData(
            backgroundColor: backgroundColor,
          ),
          drawerTheme: const DrawerThemeData(
            backgroundColor: backgroundColor,
          ),
          snackBarTheme:
              const SnackBarThemeData(backgroundColor: backgroundColor),
        ),
        builder: (context, child) {
          return Container(
              color: backgroundColor,
              child: _flavorBanner(
                  child: child ?? SizedBox.shrink(), show: kDebugMode));
        });
  }

  Widget _flavorBanner({
    required Widget child,
    bool show = true,
  }) =>
      show
          ? Banner(
              location: BannerLocation.topStart,
              message: 'kakiokosy',
              color: Colors.yellow.withOpacity(0.6),
              textStyle: TextStyle(
                fontWeight: FontWeight.w700,
                fontSize: 12.0,
                letterSpacing: 1.0,
              ),
              textDirection: TextDirection.ltr,
              child: child)
          : child;
}

==== FILE: settings_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:nottaalternative/core/authentication/auth_repository.dart';
import 'package:nottaalternative/utils/progress_hud.dart';

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
        body: Center(
            child: Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        ElevatedButton(
          onPressed: () async {
            try {
              ref.read(progressController.notifier).executeWithProgress(
                    () => ref.read(authRepositoryProvider).signOut(),
                  );
            } on Exception catch (e) {
              debugPrint('ログアウト処理中にエラーが発生しました。: $e');
            }
          },
          child: const Text('ログアウト'),
        ),
      ],
    )));
  }
}

==== FILE: record_repository.dart ====
import 'package:flutter_sound/flutter_sound.dart';
import 'package:path_provider/path_provider.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:audio_session/audio_session.dart';
part 'record_repository.g.dart';

class RecordRepository {
  FlutterSoundRecorder? _recorder;
  FlutterSoundPlayer? _player;

  Future<void> initializeRecorder() async {
    if (_recorder != null) return;

    if (await Permission.microphone.request().isGranted) {
        _recorder = FlutterSoundRecorder();
        await _recorder!.openRecorder();
    }
  }

  Future<String> startRecording() async {
    if (_recorder == null) {
      _recorder = FlutterSoundRecorder();
      await _recorder!.openRecorder();
    }

    final directory = await getApplicationDocumentsDirectory();
    final path =
        '${directory.path}/recording_${DateTime.now().millisecondsSinceEpoch}.aac';

    await _recorder!.startRecorder(
      toFile: path,
      codec: Codec.aacMP4,
    );

    return path;
  }

  Future<void> stopRecording() async {
    if (_recorder == null) return;
    await _recorder!.stopRecorder();
  }

  Future<void> disposeRecorder() async {
    if (_recorder != null) {
      await _recorder!.closeRecorder();
      _recorder = null;
    }
  }

  bool get isInitialized => _recorder != null;

  Future<void> initializePlayer() async {
    _player = FlutterSoundPlayer();
    await _player!.openPlayer();

    // TODO: Audioのセッションとは何なのかの勉強 & 本当にセッション確立の実装はここで良いのか調べる。
    final session = await AudioSession.instance;
    await session.configure(AudioSessionConfiguration(
      avAudioSessionCategory: AVAudioSessionCategory.playAndRecord,
      avAudioSessionCategoryOptions:
          AVAudioSessionCategoryOptions.allowBluetooth |
              AVAudioSessionCategoryOptions.defaultToSpeaker,
      avAudioSessionMode: AVAudioSessionMode.spokenAudio,
      avAudioSessionRouteSharingPolicy:
          AVAudioSessionRouteSharingPolicy.defaultPolicy,
      avAudioSessionSetActiveOptions: AVAudioSessionSetActiveOptions.none,
      androidAudioAttributes: const AndroidAudioAttributes(
        contentType: AndroidAudioContentType.speech,
        flags: AndroidAudioFlags.none,
        usage: AndroidAudioUsage.voiceCommunication,
      ),
      androidAudioFocusGainType: AndroidAudioFocusGainType.gain,
      androidWillPauseWhenDucked: true,
    ));


  }

  Future<void> startPlaying(String path) async {
    if (_player == null) throw Exception("音声プレイヤーが初期化されていません。");

    await _player!.startPlayer(
      fromURI: path,
      codec: Codec.aacMP4,
      whenFinished: () {
        //再生完了時コールバック
        //プロバイダーで処理するためここではnull
      },
    );
  }

  Future<void> stopPlaying() async {
    if (_player == null) return;
    await _player!.stopPlayer();
  }

  Future<void> pausePlaying() async {
    if (_player == null) return;
    await _player!.pausePlayer();
  }

  bool get isPlayerInitialized => _player != null;
}

@riverpod
RecordRepository recordRepository(RecordRepositoryRef ref) {
  return RecordRepository();
}

==== FILE: record_provider.dart ====
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'record_model.dart';
import 'record_repository.dart';

part 'record_provider.g.dart';

@riverpod
class RecordController extends _$RecordController {
  late final RecordRepository _repository;

  @override
  RecordState build() {
    _repository = ref.read(recordRepositoryProvider);
    return const RecordState();
  }

  Future<void> initRecorder() async {
    try {
      await _repository.initializeRecorder();
      state = state.copyWith(
        isRecorderInitialized: true,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
        isRecorderInitialized: false,
      );
    }
  }

  Future<void> startRecording() async {
    if (!_repository.isInitialized) await initRecorder();

    try {
      final path = await _repository.startRecording();
      state = state.copyWith(
        isRecording: true,
        path: path,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
        isRecording: false,
      );
    }
  }

  Future<void> stopRecording() async {
    if (!state.isRecording) return;

    try {
      await _repository.stopRecording();
      state = state.copyWith(
        isRecording: false,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
      );
    }
  }

  Future<void> initPlayer() async {
    try {
      await _repository.initializePlayer();
      state = state.copyWith(
        isPlayerInitialized: true,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
        isPlayerInitialized: false,
      );
    }
  }

  Future<void> startPlaying() async {
    if (!state.isPlayerInitialized) await initPlayer();
    if (state.path == null) return;

    try {
      await _repository.startPlaying(state.path!);
      state = state.copyWith(
        isPlaying: true,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
        isPlaying: false,
      );
    }
  }

  Future<void> stopPlaying() async {
    if (!state.isPlaying) return;

    try {
      await _repository.stopPlaying();
      state = state.copyWith(
        isPlaying: false,
        errorMessage: null,
      );
    } catch (e) {
      state = state.copyWith(
        errorMessage: e.toString(),
      );
    }
  }

  void dispose() {
    _repository.disposeRecorder();
  }
}

==== FILE: record_model.freezed.dart ====
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'record_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

RecordState _$RecordStateFromJson(Map<String, dynamic> json) {
  return _RecordState.fromJson(json);
}

/// @nodoc
mixin _$RecordState {
  bool get isRecording => throw _privateConstructorUsedError;
  bool get isRecorderInitialized => throw _privateConstructorUsedError;
  bool get isPlaying => throw _privateConstructorUsedError;
  bool get isPlayerInitialized => throw _privateConstructorUsedError;
  String? get path => throw _privateConstructorUsedError;
  String? get errorMessage => throw _privateConstructorUsedError;

  /// Serializes this RecordState to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of RecordState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RecordStateCopyWith<RecordState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecordStateCopyWith<$Res> {
  factory $RecordStateCopyWith(
          RecordState value, $Res Function(RecordState) then) =
      _$RecordStateCopyWithImpl<$Res, RecordState>;
  @useResult
  $Res call(
      {bool isRecording,
      bool isRecorderInitialized,
      bool isPlaying,
      bool isPlayerInitialized,
      String? path,
      String? errorMessage});
}

/// @nodoc
class _$RecordStateCopyWithImpl<$Res, $Val extends RecordState>
    implements $RecordStateCopyWith<$Res> {
  _$RecordStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RecordState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRecording = null,
    Object? isRecorderInitialized = null,
    Object? isPlaying = null,
    Object? isPlayerInitialized = null,
    Object? path = freezed,
    Object? errorMessage = freezed,
  }) {
    return _then(_value.copyWith(
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecorderInitialized: null == isRecorderInitialized
          ? _value.isRecorderInitialized
          : isRecorderInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlayerInitialized: null == isPlayerInitialized
          ? _value.isPlayerInitialized
          : isPlayerInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RecordStateImplCopyWith<$Res>
    implements $RecordStateCopyWith<$Res> {
  factory _$$RecordStateImplCopyWith(
          _$RecordStateImpl value, $Res Function(_$RecordStateImpl) then) =
      __$$RecordStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isRecording,
      bool isRecorderInitialized,
      bool isPlaying,
      bool isPlayerInitialized,
      String? path,
      String? errorMessage});
}

/// @nodoc
class __$$RecordStateImplCopyWithImpl<$Res>
    extends _$RecordStateCopyWithImpl<$Res, _$RecordStateImpl>
    implements _$$RecordStateImplCopyWith<$Res> {
  __$$RecordStateImplCopyWithImpl(
      _$RecordStateImpl _value, $Res Function(_$RecordStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of RecordState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isRecording = null,
    Object? isRecorderInitialized = null,
    Object? isPlaying = null,
    Object? isPlayerInitialized = null,
    Object? path = freezed,
    Object? errorMessage = freezed,
  }) {
    return _then(_$RecordStateImpl(
      isRecording: null == isRecording
          ? _value.isRecording
          : isRecording // ignore: cast_nullable_to_non_nullable
              as bool,
      isRecorderInitialized: null == isRecorderInitialized
          ? _value.isRecorderInitialized
          : isRecorderInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      isPlayerInitialized: null == isPlayerInitialized
          ? _value.isPlayerInitialized
          : isPlayerInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
      path: freezed == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      errorMessage: freezed == errorMessage
          ? _value.errorMessage
          : errorMessage // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$RecordStateImpl implements _RecordState {
  const _$RecordStateImpl(
      {this.isRecording = false,
      this.isRecorderInitialized = false,
      this.isPlaying = false,
      this.isPlayerInitialized = false,
      this.path,
      this.errorMessage});

  factory _$RecordStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$RecordStateImplFromJson(json);

  @override
  @JsonKey()
  final bool isRecording;
  @override
  @JsonKey()
  final bool isRecorderInitialized;
  @override
  @JsonKey()
  final bool isPlaying;
  @override
  @JsonKey()
  final bool isPlayerInitialized;
  @override
  final String? path;
  @override
  final String? errorMessage;

  @override
  String toString() {
    return 'RecordState(isRecording: $isRecording, isRecorderInitialized: $isRecorderInitialized, isPlaying: $isPlaying, isPlayerInitialized: $isPlayerInitialized, path: $path, errorMessage: $errorMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordStateImpl &&
            (identical(other.isRecording, isRecording) ||
                other.isRecording == isRecording) &&
            (identical(other.isRecorderInitialized, isRecorderInitialized) ||
                other.isRecorderInitialized == isRecorderInitialized) &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying) &&
            (identical(other.isPlayerInitialized, isPlayerInitialized) ||
                other.isPlayerInitialized == isPlayerInitialized) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.errorMessage, errorMessage) ||
                other.errorMessage == errorMessage));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      isRecording,
      isRecorderInitialized,
      isPlaying,
      isPlayerInitialized,
      path,
      errorMessage);

  /// Create a copy of RecordState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordStateImplCopyWith<_$RecordStateImpl> get copyWith =>
      __$$RecordStateImplCopyWithImpl<_$RecordStateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$RecordStateImplToJson(
      this,
    );
  }
}

abstract class _RecordState implements RecordState {
  const factory _RecordState(
      {final bool isRecording,
      final bool isRecorderInitialized,
      final bool isPlaying,
      final bool isPlayerInitialized,
      final String? path,
      final String? errorMessage}) = _$RecordStateImpl;

  factory _RecordState.fromJson(Map<String, dynamic> json) =
      _$RecordStateImpl.fromJson;

  @override
  bool get isRecording;
  @override
  bool get isRecorderInitialized;
  @override
  bool get isPlaying;
  @override
  bool get isPlayerInitialized;
  @override
  String? get path;
  @override
  String? get errorMessage;

  /// Create a copy of RecordState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RecordStateImplCopyWith<_$RecordStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

==== FILE: record_model.dart ====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'record_model.freezed.dart';
part 'record_model.g.dart';

@freezed
class RecordState with _$RecordState {
  const factory RecordState({
    @Default(false) bool isRecording,
    @Default(false) bool isRecorderInitialized,
    @Default(false) bool isPlaying,
    @Default(false) bool isPlayerInitialized,
    String? path,
    String? errorMessage,
  }) = _RecordState;

  factory RecordState.fromJson(Map<String, dynamic> json) =>
      _$RecordStateFromJson(json);
}
==== FILE: record_repository.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'record_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$recordRepositoryHash() => r'e1ea9e2a247fdd8eb16528bc152b9ff55be5a8aa';

/// See also [recordRepository].
@ProviderFor(recordRepository)
final recordRepositoryProvider = AutoDisposeProvider<RecordRepository>.internal(
  recordRepository,
  name: r'recordRepositoryProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$recordRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef RecordRepositoryRef = AutoDisposeProviderRef<RecordRepository>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: record_model.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'record_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$RecordStateImpl _$$RecordStateImplFromJson(Map<String, dynamic> json) =>
    _$RecordStateImpl(
      isRecording: json['isRecording'] as bool? ?? false,
      isRecorderInitialized: json['isRecorderInitialized'] as bool? ?? false,
      isPlaying: json['isPlaying'] as bool? ?? false,
      isPlayerInitialized: json['isPlayerInitialized'] as bool? ?? false,
      path: json['path'] as String?,
      errorMessage: json['errorMessage'] as String?,
    );

Map<String, dynamic> _$$RecordStateImplToJson(_$RecordStateImpl instance) =>
    <String, dynamic>{
      'isRecording': instance.isRecording,
      'isRecorderInitialized': instance.isRecorderInitialized,
      'isPlaying': instance.isPlaying,
      'isPlayerInitialized': instance.isPlayerInitialized,
      'path': instance.path,
      'errorMessage': instance.errorMessage,
    };

==== FILE: record_provider.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'record_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$recordControllerHash() => r'3a3bd40b659b8f4604a7bb9a945a9fabfe2206b8';

/// See also [RecordController].
@ProviderFor(RecordController)
final recordControllerProvider =
    AutoDisposeNotifierProvider<RecordController, RecordState>.internal(
  RecordController.new,
  name: r'recordControllerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$recordControllerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$RecordController = AutoDisposeNotifier<RecordState>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: record_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import '../audiosave/providers/audio_state.dart';
import 'record_provider.dart';

class RecordPage extends HookConsumerWidget {
  const RecordPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final recordState = ref.watch(recordControllerProvider);
    final controller = ref.watch(recordControllerProvider.notifier);
    final audioStateAsync = ref.watch(audioStateProvider);
    final selectedFolderId = useState<String?>(null);
    final nameController = useTextEditingController();

    useEffect(() {
      controller.initPlayer();
      controller.initRecorder();
      return () {
        controller.dispose();
      };
    }, []);

    Future<void> _saveRecording() async {
      if (recordState.path == null) return;
      if (nameController.text.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('ファイル名を入力してください')),
        );
        return;
      }

      await ref.read(audioStateProvider.notifier).saveAudioFile(
            recordState.path!,
            nameController.text,
            folderId: selectedFolderId.value,
          );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('録音'),
        actions: [
          if (recordState.path != null && !recordState.isRecording)
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _saveRecording,
            ),
        ],
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              if (recordState.errorMessage != null)
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Text(
                    recordState.errorMessage!,
                    style:
                        TextStyle(color: Theme.of(context).colorScheme.error),
                  ),
                ),
              if (recordState.isRecorderInitialized) ...[
                Text(
                  recordState.isRecording ? '録音中...' : '録音待機中',
                  style: Theme.of(context).textTheme.headlineSmall,
                ),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () {
                    if (recordState.isRecording) {
                      controller.stopRecording();
                    } else {
                      controller.startRecording();
                    }
                  },
                  child: Text(recordState.isRecording ? '録音停止' : '録音開始'),
                ),
                if (recordState.path != null) ...[
                  const SizedBox(height: 20),
                  TextField(
                    controller: nameController,
                    decoration: const InputDecoration(
                      labelText: 'ファイル名',
                      border: OutlineInputBorder(),
                    ),
                  ),
                  const SizedBox(
                    height: 20,
                  ),
                  audioStateAsync.when(
                    data: (data) => DropdownButtonFormField<String?>(
                      decoration: const InputDecoration(
                        labelText: 'フォルダ',
                        border: OutlineInputBorder(),
                      ),
                      value: selectedFolderId.value,
                      items: [
                        const DropdownMenuItem(
                          value: null,
                          child: Text('(フォルダなし)'),
                        ),
                        ...data.folders.map((folder) => DropdownMenuItem(
                              value: folder.id,
                              child: Text(folder.name),
                            ))
                      ],
                      onChanged: (value) => selectedFolderId.value = value,
                    ),
                    loading: () =>
                        const Center(child: CircularProgressIndicator()),
                    error: (error, _) => Text('エラー: $error'),
                  ),
                ],
                if (recordState.path != null && !recordState.isRecording) ...[
                  const SizedBox(
                    height: 20,
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      IconButton(
                          onPressed:recordState.isPlaying
                                ? controller.stopPlaying
                                : controller.startPlaying,
                          icon: Icon(
                            recordState.isPlaying
                                ? Icons.stop
                                : Icons.play_arrow,
                            size: 32,
                          ))
                    ],
                  )
                ]
              ],
            ],
          ),
        ),
      ),
    );
  }
}

==== FILE: audio_list_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:nottaalternative/features/audiosave/providers/audio_player_state.dart';

import 'model/audio_file_model.dart';
import 'model/audio_folder_model.dart';
import 'providers/audio_state.dart';

class AudioListPage extends HookConsumerWidget {
  const AudioListPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final audioStateAsync = ref.watch(audioStateProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text("録音一覧"),
        actions: [
          IconButton(
            onPressed: () => _showCreateFolderDialog(context, ref),
            icon: const Icon(Icons.create_new_folder),
          ),
        ],
      ),
      body: audioStateAsync.when(
        data: (data) =>
            _buildContent(context, ref, data.folders, data.audioFiles),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, stack) => Center(child: Text('エラーが発生しました: $error')),
      ),
    );
  }

  Widget _buildContent(BuildContext context, WidgetRef ref,
      List<AudioFolder> folders, List<AudioFile> audioFiles) {
    return ListView(
      children: [
        ...folders.map(
            (folder) => _buildFolderTile(context, ref, folder, audioFiles)),
        ...audioFiles
            .where((file) => file.folderId == null)
            .map((file) => _buildAudioFileTile(context, ref, file)),
      ],
    );
  }

  Widget _buildFolderTile(BuildContext context, WidgetRef ref,
      AudioFolder folder, List<AudioFile> allAudioFiles) {
    final folderAudioFiles =
        allAudioFiles.where((file) => file.folderId == folder.id).toList();

    return ExpansionTile(
      title: Text(folder.name),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: const Icon(Icons.delete),
            onPressed: () => _showDeleteFolderDialog(context, ref, folder),
          ),
          const Icon(Icons.expand_more),
        ],
      ),
      children: folderAudioFiles
          .map((file) => _buildAudioFileTile(context, ref, file))
          .toList(),
    );
  }

  Widget _buildAudioFileTile(
      BuildContext context, WidgetRef ref, AudioFile audioFile) {
    final playerState = ref.watch(audioPlayerControllerProvider);
    final playerController = ref.watch(audioPlayerControllerProvider.notifier);
    final isCurrentlyPlaying = playerState.currentlyPlaingId == audioFile.id;

    return ListTile(
        title: Text(audioFile.name),
        subtitle: Text('作成日: ${_formatDate(audioFile.createdAt)}'),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            IconButton(
              icon: Icon(isCurrentlyPlaying && playerState.isPlaying
                  ? Icons.stop
                  : Icons.play_arrow),
              onPressed: () async {
                // TODO: 音声ファイル再生ボタンをここに置く
                try {
                  if (isCurrentlyPlaying && playerState.isPlaying) {
                    await playerController.stopAudio();
                  } else {
                    print('これオーディオIDだ！！');
                    print(audioFile.path);
                    print("#################");
                    await playerController.playAudio(
                        audioFile.id, audioFile.path);
                  }
                } catch (e) {
                  if (context.mounted) {
                    ScaffoldMessenger.of(context).showSnackBar(
                      SnackBar(
                        content: Text('再生中にエラーが発生しました: $e'),
                        backgroundColor: Theme.of(context).colorScheme.error,
                      ),
                    );
                  }
                }
              },
            ),
            IconButton(
              onPressed: () => _showDeleteAudioDialog(context, ref, audioFile),
              icon: const Icon(Icons.delete),
            )
          ],
        ));
  }

  // TODO: utilsフォルダなどに移す
  String _formatDate(DateTime date) {
    return '${date.year}/${date.month}/${date.day} ${date.hour}:${date.minute}';
  }

  Future<void> _showCreateFolderDialog(
      BuildContext context, WidgetRef ref) async {
    final controller = TextEditingController();
    final result = await showDialog<String>(
        context: context,
        builder: (context) => AlertDialog(
              title: const Text('フォルダを作成'),
              content: TextField(
                controller: controller,
                decoration: const InputDecoration(
                  labelText: 'フォルダ名',
                ),
              ),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context),
                  child: const Text('キャンセル'),
                ),
                TextButton(
                  onPressed: () => Navigator.pop(context, controller.text),
                  child: const Text('作成'),
                ),
              ],
            ));

    if (result != null && result.isNotEmpty) {
      await ref.read(audioStateProvider.notifier).createFolder(result);
    }
  }

  Future<void> _showDeleteFolderDialog(
      BuildContext context, WidgetRef ref, AudioFolder folder) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('フォルダを削除'),
        content: Text('フォルダ"${folder.name}"を削除しますか？¥n中の音声ファイルもすべて削除されます。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('キャンセル'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text("削除"),
          ),
        ],
      ),
    );

    if (result == true) {
      await ref.read(audioStateProvider.notifier).deleteFolder(folder.id);
    }
  }

  Future<void> _showDeleteAudioDialog(
      BuildContext context, WidgetRef ref, AudioFile audioFile) async {
    final result = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
              title: const Text('音声ファイルを削除'),
              content: Text('音声ファイル "${audioFile.name}を削除しますか？'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: const Text('キャンセル'),
                ),
                TextButton(
                    onPressed: () => Navigator.pop(context, true),
                    child: const Text('削除'))
              ],
            ));

    if (result == true) {
      await ref.read(audioStateProvider.notifier).deleteAudioFile(audioFile.id);
    }
  }
}

==== FILE: audio_player_state.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_player_state.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$audioPlayerControllerHash() =>
    r'feb64e01950f68756f4f06d77a44e397622faec1';

/// See also [AudioPlayerController].
@ProviderFor(AudioPlayerController)
final audioPlayerControllerProvider =
    AutoDisposeNotifierProvider<AudioPlayerController, AudioPlayer>.internal(
  AudioPlayerController.new,
  name: r'audioPlayerControllerProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$audioPlayerControllerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$AudioPlayerController = AutoDisposeNotifier<AudioPlayer>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: audio_player_state.dart ====
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../model/audio_player_model.dart';
import '../repositories/audio_repository.dart';
part "audio_player_state.g.dart";

@riverpod
class AudioPlayerController extends _$AudioPlayerController {
  late final AudioRepository _repository;
  @override
  AudioPlayer build() {
    _repository = ref.read(audioRepositoryProvider);

    ref.onDispose(() {
      ref.read(audioRepositoryProvider).dispose();
    });
    return const AudioPlayer();
  }

  Future<void> initPlayer() async {
    try {
      await _repository.initializePlayer();
      state = state.copyWith(
        isPlayerInitialized: true,
      );
    } catch (e) {
      state = state.copyWith(
        isPlayerInitialized: false,
      );
    }
  }

  Future<void> playAudio(String id, String path) async {
    if (!_repository.isInitialized) await initPlayer();

    try {
      await _repository.startPlaying(path);
      state = state.copyWith(
        isPlaying: true,
        currentlyPlaingId: id,
      );
    } catch (e) {
      state = state.copyWith(
        isPlaying: false,
        currentlyPlaingId: null,
      );
      rethrow;
    }
  }

  Future<void> stopAudio() async {
    await _repository.stopPlaying();
    state = const AudioPlayer();
  }
}

==== FILE: audio_state.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_state.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$audioStateHash() => r'6cb56e01a13e2421a1070756bb5de196b2f3333d';

/// See also [AudioState].
@ProviderFor(AudioState)
final audioStateProvider = AutoDisposeAsyncNotifierProvider<AudioState,
    ({List<AudioFolder> folders, List<AudioFile> audioFiles})>.internal(
  AudioState.new,
  name: r'audioStateProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$audioStateHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef _$AudioState = AutoDisposeAsyncNotifier<
    ({List<AudioFolder> folders, List<AudioFile> audioFiles})>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: audio_state.dart ====
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../model/audio_file_model.dart';
import '../model/audio_folder_model.dart';
import '../repositories/audio_repository.dart';

part 'audio_state.g.dart';

@riverpod
class AudioState extends _$AudioState {
  @override
  Future<({List<AudioFolder> folders, List<AudioFile> audioFiles})>
      build() async {
    final repository = ref.read(audioRepositoryProvider);
    final folders = await repository.getFolders();
    final audioFiles = await repository.getAudioFiles();
    return (folders: folders, audioFiles: audioFiles);
  }

  Future<void> createFolder(String name) async {
    final repository = ref.read(audioRepositoryProvider);
    await repository.createFolder(name);
    ref.invalidateSelf();
  }

  Future<void> saveAudioFile(String path, String name,
      {String? folderId}) async {
    final repository = ref.read(audioRepositoryProvider);
    await repository.saveAudioFile(path, name, folderId: folderId);
    ref.invalidateSelf();
  }

  Future<void> deleteAudioFile(String id) async {
    final repository = ref.read(audioRepositoryProvider);
    await repository.deleteAudioFile(id);
    ref.invalidateSelf();
  }

  Future<void> deleteFolder(String id) async {
    final repository = ref.read(audioRepositoryProvider);
    await repository.deleteFolder(id);
    ref.invalidateSelf();
  }
}

==== FILE: audio_repository.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$audioRepositoryHash() => r'8317c335b4c30f8c1eb34be6ecebbfb628379fe5';

/// See also [audioRepository].
@ProviderFor(audioRepository)
final audioRepositoryProvider = AutoDisposeProvider<AudioRepository>.internal(
  audioRepository,
  name: r'audioRepositoryProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$audioRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef AudioRepositoryRef = AutoDisposeProviderRef<AudioRepository>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

==== FILE: audio_repository.dart ====
import 'dart:convert';
import 'package:audio_session/audio_session.dart';
import 'package:flutter_sound/flutter_sound.dart';
import 'package:path_provider/path_provider.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'dart:io';

import 'package:uuid/uuid.dart';

import '../model/audio_file_model.dart';
import '../model/audio_folder_model.dart';

part 'audio_repository.g.dart';

class AudioRepository {
  static const _folderDataFileName = "folders.json";
  static const _audioDataFileName = "audio_files.json";
  final _uuid = const Uuid();
  FlutterSoundPlayer? _player;

  Future<void> initializePlayer() async {
    _player = FlutterSoundPlayer();
    await _player!.openPlayer();

    final session = await AudioSession.instance;
    await session.configure(AudioSessionConfiguration(
      avAudioSessionCategory: AVAudioSessionCategory.playAndRecord,
      avAudioSessionCategoryOptions:
          AVAudioSessionCategoryOptions.allowBluetooth |
              AVAudioSessionCategoryOptions.defaultToSpeaker,
      avAudioSessionMode: AVAudioSessionMode.spokenAudio,
      avAudioSessionRouteSharingPolicy:
          AVAudioSessionRouteSharingPolicy.defaultPolicy,
      androidAudioAttributes: const AndroidAudioAttributes(
        contentType: AndroidAudioContentType.speech,
        flags: AndroidAudioFlags.none,
        usage: AndroidAudioUsage.voiceCommunication,
      ),
      androidAudioFocusGainType: AndroidAudioFocusGainType.gain,
      androidWillPauseWhenDucked: true,
    ));
  }

  Future<void> startPlaying(String path) async {
    if (_player == null) throw Exception("音声プレイヤーが初期化されていません。");
    await _player!.startPlayer(
      fromURI: path,
      codec: Codec.aacMP4,
      whenFinished: () {},
    );
  }

  Future<void> stopPlaying() async {
    if (_player == null) return;
    await _player!.stopPlayer();
  }

  Future<void> dispose() async {
    await _player!.closePlayer();
  }

  bool get isPlaying => _player!.isPlaying;
  bool get isInitialized => _player != null;

  Future<String> get _localPath async {
    // Q: この関数でアプリのディレクトリ情報を取得できる？
    final directory = await getApplicationDocumentsDirectory();
    return directory.path;
  }

  Future<File> get _folderFile async {
    final path = await _localPath;
    return File('$path/$_folderDataFileName');
  }

  Future<File> get _audioFile async {
    final path = await _localPath;
    return File("$path/$_audioDataFileName");
  }

  Future<List<AudioFolder>> getFolders() async {
    try {
      final file = await _folderFile;
      if (!await file.exists()) return [];

      final contents = await file.readAsString();
      final List<dynamic> jsonList = json.decode(contents);
      return jsonList.map((json) => AudioFolder.fromJson(json)).toList();
    } catch (e) {
      return [];
    }
  }

  Future<List<AudioFile>> getAudioFiles() async {
    try {
      final file = await _audioFile;
      if (!await file.exists()) return [];

      final contents = await file.readAsString();
      final List<dynamic> jsonList = json.decode(contents);
      return jsonList.map((json) => AudioFile.fromJson(json)).toList();
    } catch (e) {
      return [];
    }
  }

  Future<AudioFolder> createFolder(String name) async {
    final folders = await getFolders();
    final newFolder = AudioFolder(
      id: _uuid.v4(),
      name: name,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
    );
    folders.add(newFolder);
    await _saveFolders(folders);
    return newFolder;
  }

  Future<AudioFile> saveAudioFile(String originalPath, String name,
      {String? folderId}) async {
    final directory = await getApplicationDocumentsDirectory();
    final String newFileName = '${_uuid.v4()}.aac';
    final String newPath = '${directory.path}/audio_files/$newFileName';

    // audio_filesディレクトリが存在しなかったら作成
    await Directory('${directory.path}/audio_files').create(recursive: true);

    // 録音ファイルの永続化
    await File(originalPath).copy(newPath);

    final audioFile = AudioFile(
      id: _uuid.v4(),
      name: name,
      path: newPath,
      createdAt: DateTime.now(),
      updatedAt: DateTime.now(),
      folderId: folderId,
    );

    final audioFiles = await getAudioFiles();
    audioFiles.add(audioFile);
    await _saveAudioFiles(audioFiles);

    if (folderId != null) {
      await _addAudioFileToFolder(audioFile.id, folderId);
    }

    return audioFile;
  }

  Future<void> _addAudioFileToFolder(
      String audioFileId, String folderId) async {
    final folders = await getFolders();
    // Q: どういった処理だろう？？
    final folderIndex = folders.indexWhere((folder) => folder.id == folderId);
    if (folderIndex == -1) return;

    // Q: これもわからない...
    final updatedFolder = folders[folderIndex].copyWith(
      audioFileIds: [...folders[folderIndex].audioFileIds, audioFileId],
      updatedAt: DateTime.now(),
    );

    folders[folderIndex] = updatedFolder;
    await _saveFolders(folders);
  }

  Future<void> _saveFolders(List<AudioFolder> folders) async {
    final file = await _folderFile;

    // Q: ここもちょっと詳しく知りたい感じがする。おそらくローカルのディレクトリにJson形式で書き込んでいるのだとは思う
    await file
        .writeAsString(json.encode(folders.map((f) => f.toJson()).toList()));
  }

  Future<void> _saveAudioFiles(List<AudioFile> audioFiles) async {
    final file = await _audioFile;
    await file
        .writeAsString(json.encode(audioFiles.map((f) => f.toJson()).toList()));
  }

  Future<void> deleteAudioFile(String id) async {
    final audioFiles = await getAudioFiles();
    final fileToDelete = audioFiles.firstWhere((file) => file.id == id);

    // 実際のファイル削除処理
    await File(fileToDelete.path).delete();

    audioFiles.removeWhere((file) => file.id == id);
    await _saveAudioFiles(audioFiles);

    // フォルダが存在していたらフォルダからも削除する
    if (fileToDelete.folderId != null) {
      final folders = await getFolders();
      final folderIndex =
          folders.indexWhere((folder) => folder.id == fileToDelete.folderId);
      if (folderIndex != -1) {
        // Q: ここの処理も詳しく知りたい
        final updatedFolder = folders[folderIndex].copyWith(
          audioFileIds: folders[folderIndex]
              .audioFileIds
              .where((fileId) => fileId != id)
              .toList(),
          updatedAt: DateTime.now(),
        );
        folders[folderIndex] = updatedFolder;
        await _saveFolders(folders);
      }
    }
  }

  Future<void> deleteFolder(String id) async {
    final folders = await getFolders();
    final audioFiles = await getAudioFiles();

    // フォルダ内の全音声ファイルを削除
    final folderToDelete = folders.firstWhere((folder) => folder.id == id);
    for (final audioFileId in folderToDelete.audioFileIds) {
      final audioFile = audioFiles.firstWhere((file) => file.id == audioFileId);
      await File(audioFile.path).delete();
    }

    // フォルダを削除してaudioファイルをアップデート
    folders.removeWhere((folder) => folder.id == id);
    audioFiles.removeWhere((file) => file.folderId == id);

    await _saveFolders(folders);
    await _saveAudioFiles(audioFiles);
  }
}

@riverpod
AudioRepository audioRepository(AudioRepositoryRef ref) {
  return AudioRepository();
}

==== FILE: audio_file_model.dart ====
import 'package:freezed_annotation/freezed_annotation.dart';

part 'audio_file_model.freezed.dart';
part 'audio_file_model.g.dart';

@freezed
class AudioFile with _$AudioFile {
  const factory AudioFile({
    required String id,
    required String name,
    required String path,
    required DateTime createdAt,
    required DateTime updatedAt,
    String? folderId,
  }) = _AudioFile;

  factory AudioFile.fromJson(Map<String, dynamic> json) =>
      _$AudioFileFromJson(json);
}

==== FILE: audio_folder_model.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_folder_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AudioFolderImpl _$$AudioFolderImplFromJson(Map<String, dynamic> json) =>
    _$AudioFolderImpl(
      id: json['id'] as String,
      name: json['name'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      audioFileIds: (json['audioFileIds'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          const [],
    );

Map<String, dynamic> _$$AudioFolderImplToJson(_$AudioFolderImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'audioFileIds': instance.audioFileIds,
    };

==== FILE: audio_file_model.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_file_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AudioFileImpl _$$AudioFileImplFromJson(Map<String, dynamic> json) =>
    _$AudioFileImpl(
      id: json['id'] as String,
      name: json['name'] as String,
      path: json['path'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      folderId: json['folderId'] as String?,
    );

Map<String, dynamic> _$$AudioFileImplToJson(_$AudioFileImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'name': instance.name,
      'path': instance.path,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'folderId': instance.folderId,
    };

==== FILE: audio_player_model.dart ====
import 'package:flutter/rendering.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'audio_player_model.freezed.dart';
part 'audio_player_model.g.dart';


@freezed  
class AudioPlayer with _$AudioPlayer {
  const factory AudioPlayer({
    @Default(false) bool isPlaying,
    String? currentlyPlaingId,
    @Default(false) bool isPlayerInitialized,
  }) = _AudioPlayer;

  factory AudioPlayer.fromJson(Map<String, dynamic> json) => 
    _$AudioPlayerFromJson(json);

}
==== FILE: audio_player_model.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'audio_player_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$AudioPlayerImpl _$$AudioPlayerImplFromJson(Map<String, dynamic> json) =>
    _$AudioPlayerImpl(
      isPlaying: json['isPlaying'] as bool? ?? false,
      currentlyPlaingId: json['currentlyPlaingId'] as String?,
      isPlayerInitialized: json['isPlayerInitialized'] as bool? ?? false,
    );

Map<String, dynamic> _$$AudioPlayerImplToJson(_$AudioPlayerImpl instance) =>
    <String, dynamic>{
      'isPlaying': instance.isPlaying,
      'currentlyPlaingId': instance.currentlyPlaingId,
      'isPlayerInitialized': instance.isPlayerInitialized,
    };

==== FILE: audio_file_model.freezed.dart ====
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'audio_file_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AudioFile _$AudioFileFromJson(Map<String, dynamic> json) {
  return _AudioFile.fromJson(json);
}

/// @nodoc
mixin _$AudioFile {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get path => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  String? get folderId => throw _privateConstructorUsedError;

  /// Serializes this AudioFile to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AudioFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AudioFileCopyWith<AudioFile> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioFileCopyWith<$Res> {
  factory $AudioFileCopyWith(AudioFile value, $Res Function(AudioFile) then) =
      _$AudioFileCopyWithImpl<$Res, AudioFile>;
  @useResult
  $Res call(
      {String id,
      String name,
      String path,
      DateTime createdAt,
      DateTime updatedAt,
      String? folderId});
}

/// @nodoc
class _$AudioFileCopyWithImpl<$Res, $Val extends AudioFile>
    implements $AudioFileCopyWith<$Res> {
  _$AudioFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AudioFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? path = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? folderId = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      folderId: freezed == folderId
          ? _value.folderId
          : folderId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AudioFileImplCopyWith<$Res>
    implements $AudioFileCopyWith<$Res> {
  factory _$$AudioFileImplCopyWith(
          _$AudioFileImpl value, $Res Function(_$AudioFileImpl) then) =
      __$$AudioFileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      String path,
      DateTime createdAt,
      DateTime updatedAt,
      String? folderId});
}

/// @nodoc
class __$$AudioFileImplCopyWithImpl<$Res>
    extends _$AudioFileCopyWithImpl<$Res, _$AudioFileImpl>
    implements _$$AudioFileImplCopyWith<$Res> {
  __$$AudioFileImplCopyWithImpl(
      _$AudioFileImpl _value, $Res Function(_$AudioFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of AudioFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? path = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? folderId = freezed,
  }) {
    return _then(_$AudioFileImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      folderId: freezed == folderId
          ? _value.folderId
          : folderId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AudioFileImpl implements _AudioFile {
  const _$AudioFileImpl(
      {required this.id,
      required this.name,
      required this.path,
      required this.createdAt,
      required this.updatedAt,
      this.folderId});

  factory _$AudioFileImpl.fromJson(Map<String, dynamic> json) =>
      _$$AudioFileImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final String path;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  @override
  final String? folderId;

  @override
  String toString() {
    return 'AudioFile(id: $id, name: $name, path: $path, createdAt: $createdAt, updatedAt: $updatedAt, folderId: $folderId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AudioFileImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.folderId, folderId) ||
                other.folderId == folderId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, name, path, createdAt, updatedAt, folderId);

  /// Create a copy of AudioFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AudioFileImplCopyWith<_$AudioFileImpl> get copyWith =>
      __$$AudioFileImplCopyWithImpl<_$AudioFileImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AudioFileImplToJson(
      this,
    );
  }
}

abstract class _AudioFile implements AudioFile {
  const factory _AudioFile(
      {required final String id,
      required final String name,
      required final String path,
      required final DateTime createdAt,
      required final DateTime updatedAt,
      final String? folderId}) = _$AudioFileImpl;

  factory _AudioFile.fromJson(Map<String, dynamic> json) =
      _$AudioFileImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  String get path;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  String? get folderId;

  /// Create a copy of AudioFile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AudioFileImplCopyWith<_$AudioFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

==== FILE: audio_folder_model.dart ====
import 'package:flutter/rendering.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'audio_folder_model.freezed.dart';
part 'audio_folder_model.g.dart';

@freezed
class AudioFolder with _$AudioFolder {
  const factory AudioFolder({
    required String id,
    required String name,
    required DateTime createdAt,
    required DateTime updatedAt,
    @Default([]) List<String> audioFileIds,
  }) = _AudioFolder;

  factory AudioFolder.fromJson(Map<String, dynamic> json) =>
      _$AudioFolderFromJson(json);
}

==== FILE: audio_folder_model.freezed.dart ====
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'audio_folder_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AudioFolder _$AudioFolderFromJson(Map<String, dynamic> json) {
  return _AudioFolder.fromJson(json);
}

/// @nodoc
mixin _$AudioFolder {
  String get id => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  List<String> get audioFileIds => throw _privateConstructorUsedError;

  /// Serializes this AudioFolder to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AudioFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AudioFolderCopyWith<AudioFolder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioFolderCopyWith<$Res> {
  factory $AudioFolderCopyWith(
          AudioFolder value, $Res Function(AudioFolder) then) =
      _$AudioFolderCopyWithImpl<$Res, AudioFolder>;
  @useResult
  $Res call(
      {String id,
      String name,
      DateTime createdAt,
      DateTime updatedAt,
      List<String> audioFileIds});
}

/// @nodoc
class _$AudioFolderCopyWithImpl<$Res, $Val extends AudioFolder>
    implements $AudioFolderCopyWith<$Res> {
  _$AudioFolderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AudioFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? audioFileIds = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      audioFileIds: null == audioFileIds
          ? _value.audioFileIds
          : audioFileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AudioFolderImplCopyWith<$Res>
    implements $AudioFolderCopyWith<$Res> {
  factory _$$AudioFolderImplCopyWith(
          _$AudioFolderImpl value, $Res Function(_$AudioFolderImpl) then) =
      __$$AudioFolderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String name,
      DateTime createdAt,
      DateTime updatedAt,
      List<String> audioFileIds});
}

/// @nodoc
class __$$AudioFolderImplCopyWithImpl<$Res>
    extends _$AudioFolderCopyWithImpl<$Res, _$AudioFolderImpl>
    implements _$$AudioFolderImplCopyWith<$Res> {
  __$$AudioFolderImplCopyWithImpl(
      _$AudioFolderImpl _value, $Res Function(_$AudioFolderImpl) _then)
      : super(_value, _then);

  /// Create a copy of AudioFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? name = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? audioFileIds = null,
  }) {
    return _then(_$AudioFolderImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      audioFileIds: null == audioFileIds
          ? _value._audioFileIds
          : audioFileIds // ignore: cast_nullable_to_non_nullable
              as List<String>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AudioFolderImpl implements _AudioFolder {
  const _$AudioFolderImpl(
      {required this.id,
      required this.name,
      required this.createdAt,
      required this.updatedAt,
      final List<String> audioFileIds = const []})
      : _audioFileIds = audioFileIds;

  factory _$AudioFolderImpl.fromJson(Map<String, dynamic> json) =>
      _$$AudioFolderImplFromJson(json);

  @override
  final String id;
  @override
  final String name;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  final List<String> _audioFileIds;
  @override
  @JsonKey()
  List<String> get audioFileIds {
    if (_audioFileIds is EqualUnmodifiableListView) return _audioFileIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_audioFileIds);
  }

  @override
  String toString() {
    return 'AudioFolder(id: $id, name: $name, createdAt: $createdAt, updatedAt: $updatedAt, audioFileIds: $audioFileIds)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AudioFolderImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            const DeepCollectionEquality()
                .equals(other._audioFileIds, _audioFileIds));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, name, createdAt, updatedAt,
      const DeepCollectionEquality().hash(_audioFileIds));

  /// Create a copy of AudioFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AudioFolderImplCopyWith<_$AudioFolderImpl> get copyWith =>
      __$$AudioFolderImplCopyWithImpl<_$AudioFolderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AudioFolderImplToJson(
      this,
    );
  }
}

abstract class _AudioFolder implements AudioFolder {
  const factory _AudioFolder(
      {required final String id,
      required final String name,
      required final DateTime createdAt,
      required final DateTime updatedAt,
      final List<String> audioFileIds}) = _$AudioFolderImpl;

  factory _AudioFolder.fromJson(Map<String, dynamic> json) =
      _$AudioFolderImpl.fromJson;

  @override
  String get id;
  @override
  String get name;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  List<String> get audioFileIds;

  /// Create a copy of AudioFolder
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AudioFolderImplCopyWith<_$AudioFolderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

==== FILE: audio_player_model.freezed.dart ====
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'audio_player_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

AudioPlayer _$AudioPlayerFromJson(Map<String, dynamic> json) {
  return _AudioPlayer.fromJson(json);
}

/// @nodoc
mixin _$AudioPlayer {
  bool get isPlaying => throw _privateConstructorUsedError;
  String? get currentlyPlaingId => throw _privateConstructorUsedError;
  bool get isPlayerInitialized => throw _privateConstructorUsedError;

  /// Serializes this AudioPlayer to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AudioPlayer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AudioPlayerCopyWith<AudioPlayer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AudioPlayerCopyWith<$Res> {
  factory $AudioPlayerCopyWith(
          AudioPlayer value, $Res Function(AudioPlayer) then) =
      _$AudioPlayerCopyWithImpl<$Res, AudioPlayer>;
  @useResult
  $Res call(
      {bool isPlaying, String? currentlyPlaingId, bool isPlayerInitialized});
}

/// @nodoc
class _$AudioPlayerCopyWithImpl<$Res, $Val extends AudioPlayer>
    implements $AudioPlayerCopyWith<$Res> {
  _$AudioPlayerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AudioPlayer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPlaying = null,
    Object? currentlyPlaingId = freezed,
    Object? isPlayerInitialized = null,
  }) {
    return _then(_value.copyWith(
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      currentlyPlaingId: freezed == currentlyPlaingId
          ? _value.currentlyPlaingId
          : currentlyPlaingId // ignore: cast_nullable_to_non_nullable
              as String?,
      isPlayerInitialized: null == isPlayerInitialized
          ? _value.isPlayerInitialized
          : isPlayerInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AudioPlayerImplCopyWith<$Res>
    implements $AudioPlayerCopyWith<$Res> {
  factory _$$AudioPlayerImplCopyWith(
          _$AudioPlayerImpl value, $Res Function(_$AudioPlayerImpl) then) =
      __$$AudioPlayerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool isPlaying, String? currentlyPlaingId, bool isPlayerInitialized});
}

/// @nodoc
class __$$AudioPlayerImplCopyWithImpl<$Res>
    extends _$AudioPlayerCopyWithImpl<$Res, _$AudioPlayerImpl>
    implements _$$AudioPlayerImplCopyWith<$Res> {
  __$$AudioPlayerImplCopyWithImpl(
      _$AudioPlayerImpl _value, $Res Function(_$AudioPlayerImpl) _then)
      : super(_value, _then);

  /// Create a copy of AudioPlayer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isPlaying = null,
    Object? currentlyPlaingId = freezed,
    Object? isPlayerInitialized = null,
  }) {
    return _then(_$AudioPlayerImpl(
      isPlaying: null == isPlaying
          ? _value.isPlaying
          : isPlaying // ignore: cast_nullable_to_non_nullable
              as bool,
      currentlyPlaingId: freezed == currentlyPlaingId
          ? _value.currentlyPlaingId
          : currentlyPlaingId // ignore: cast_nullable_to_non_nullable
              as String?,
      isPlayerInitialized: null == isPlayerInitialized
          ? _value.isPlayerInitialized
          : isPlayerInitialized // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AudioPlayerImpl implements _AudioPlayer {
  const _$AudioPlayerImpl(
      {this.isPlaying = false,
      this.currentlyPlaingId,
      this.isPlayerInitialized = false});

  factory _$AudioPlayerImpl.fromJson(Map<String, dynamic> json) =>
      _$$AudioPlayerImplFromJson(json);

  @override
  @JsonKey()
  final bool isPlaying;
  @override
  final String? currentlyPlaingId;
  @override
  @JsonKey()
  final bool isPlayerInitialized;

  @override
  String toString() {
    return 'AudioPlayer(isPlaying: $isPlaying, currentlyPlaingId: $currentlyPlaingId, isPlayerInitialized: $isPlayerInitialized)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AudioPlayerImpl &&
            (identical(other.isPlaying, isPlaying) ||
                other.isPlaying == isPlaying) &&
            (identical(other.currentlyPlaingId, currentlyPlaingId) ||
                other.currentlyPlaingId == currentlyPlaingId) &&
            (identical(other.isPlayerInitialized, isPlayerInitialized) ||
                other.isPlayerInitialized == isPlayerInitialized));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType, isPlaying, currentlyPlaingId, isPlayerInitialized);

  /// Create a copy of AudioPlayer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AudioPlayerImplCopyWith<_$AudioPlayerImpl> get copyWith =>
      __$$AudioPlayerImplCopyWithImpl<_$AudioPlayerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AudioPlayerImplToJson(
      this,
    );
  }
}

abstract class _AudioPlayer implements AudioPlayer {
  const factory _AudioPlayer(
      {final bool isPlaying,
      final String? currentlyPlaingId,
      final bool isPlayerInitialized}) = _$AudioPlayerImpl;

  factory _AudioPlayer.fromJson(Map<String, dynamic> json) =
      _$AudioPlayerImpl.fromJson;

  @override
  bool get isPlaying;
  @override
  String? get currentlyPlaingId;
  @override
  bool get isPlayerInitialized;

  /// Create a copy of AudioPlayer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AudioPlayerImplCopyWith<_$AudioPlayerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

==== FILE: transcript_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class TranscriptPage extends ConsumerWidget {
  const TranscriptPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: Text('this is transcript page'),
    );
  }
}

==== FILE: signin_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:nottaalternative/core/authentication/auth_repository.dart';
import 'package:nottaalternative/utils/progress_hud.dart';

class SignInPage extends ConsumerWidget {
  const SignInPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: Center(
          child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          ElevatedButton(
            onPressed: () async {
              try {
                await ref.read(progressController.notifier).executeWithProgress(
                      () => ref.read(authRepositoryProvider).signUpWithGoogle(),
                    );
              } on Exception catch (e) {
                debugPrint('ログイン処理中にエラーが発生しました.: $e');
              }
            },
            child: const Text('Sign in with Google'),
          ),
        ],
      )),
    );
  }
}

==== FILE: transcription_detail_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class TranscriptionDetailPage extends ConsumerWidget {
  const TranscriptionDetailPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // TODO: implement build
    return Scaffold(
      body: Text('this is transcription detail page'),
    );
  }
}

==== FILE: transcriptions_page.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class TranscriptionsPage extends ConsumerWidget {
  const TranscriptionsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // TODO: implement build
    return Scaffold(
      body: Text('this is transcriptions page'),
    );
  }
}

==== FILE: progress_hud.dart ====
import 'package:flutter/material.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';

class ProgressHUD extends ConsumerWidget {
  const ProgressHUD({
    super.key,
    required this.child,
    this.useBoxIndicator = true,
    this.label,
    this.indicatorWidget,
  });

  final Widget child;
  final bool useBoxIndicator;
  final String? label;
  final Widget? indicatorWidget;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final show = ref.watch(
      progressController.select((s) => s.show),
    );
    return Barrier(
      show: show,
      label: label,
      useBoxIndicator: useBoxIndicator,
      boxWidget: indicatorWidget,
      child: child,
    );
  }
}

// ここより以下controllerの部分だけ別ファイルに移しても良さそう

final progressController = ChangeNotifierProvider(
  (ref) => ProgressController(),
);

class ProgressController extends ChangeNotifier {
  bool _show = false;
  bool get show => _show;

  Future<T> executeWithProgress<T>(Future<T> Function() f) async {
    try {
      _show = true;
      notifyListeners();
      return await f();
    } finally {
      _show = false;
      notifyListeners();
    }
  }
}

// ここより以下別のbarrier.dartなどに移す必要性あり

class Barrier extends StatelessWidget {
  const Barrier({
    super.key,
    required this.child,
    required this.show,
    this.switchDuration = const Duration(milliseconds: 300),
    // this.timeout = const Duration(seconds: 30),
    this.backgroundColor,
    this.useBoxIndicator = false,
    this.boxBackgroundColor,
    this.boxWidget,
    this.label,
  });

  final Widget child;
  final bool show;
  final Duration switchDuration;
  // MEMO(tsuruoka): Future Work
  // final Duration timeout;
  final Color? backgroundColor;
  final bool useBoxIndicator;
  final Color? boxBackgroundColor;
  final String? label;
  final Widget? boxWidget;

  @override
  Widget build(BuildContext context) {
    final useBoxIndicator = this.useBoxIndicator || label != null;
    final boxWidget = this.boxWidget;
    return Stack(
      children: [
        child,
        AnimatedSwitcher(
          duration: switchDuration,
          switchInCurve: Curves.easeIn,
          switchOutCurve: Curves.easeOut,
          child: show
              ? Stack(
                  children: [
                    ModalBarrier(
                      color: backgroundColor ?? Colors.black45,
                      dismissible: false,
                    ),
                    boxWidget == null
                        ? _CenteredIndicator(
                            useBoxIndicator: useBoxIndicator,
                            label: label,
                            boxBackgroundColor: boxBackgroundColor,
                            child: const CircularProgressIndicator(),
                          )
                        : _CenteredIndicator(
                            useBoxIndicator: useBoxIndicator,
                            label: label,
                            boxBackgroundColor: boxBackgroundColor,
                            child: boxWidget,
                          ),
                  ],
                )
              : const SizedBox.shrink(),
        ),
      ],
    );
  }
}

class _CenteredIndicator extends StatelessWidget {
  const _CenteredIndicator({
    required this.useBoxIndicator,
    required this.boxBackgroundColor,
    required this.label,
    required this.child,
  });

  final bool useBoxIndicator;
  final Color? boxBackgroundColor;
  final String? label;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: useBoxIndicator
          ? _DecoratedBox(
              label: label,
              backgroundColor: boxBackgroundColor,
              child: child,
            )
          : child,
    );
  }
}

class _DecoratedBox extends StatelessWidget {
  const _DecoratedBox({
    required this.child,
    this.label,
    this.backgroundColor,
  });

  final String? label;
  final Color? backgroundColor;
  final Widget child;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return DecoratedBox(
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: backgroundColor ?? theme.scaffoldBackgroundColor,
      ),
      child: Padding(
        padding: label == null
            ? const EdgeInsets.all(28)
            : const EdgeInsets.all(20).copyWith(bottom: 16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            child,
            if (label != null)
              Padding(
                padding: const EdgeInsets.only(top: 16),
                child: Text(
                  label!,
                  style: theme.textTheme.bodyMedium,
                ),
              ),
          ],
        ),
      ),
    );
  }
}

==== FILE: main.dart ====
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:nottaalternative/app/app.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

FutureOr<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  WidgetsApp.debugAllowBannerOverride = false;

  // .envの読み込み
  await dotenv.load(fileName: '.dev.env');
  debugPrint('dev.env initialized');
  // supabaseの初期化
  await Supabase.initialize(
      url: dotenv.env['SUPABASE_URL']!,
      anonKey: dotenv.env['SUPABASE_ANON_KEY']!,
      debug: true);
  debugPrint('supabase initialized!');
  runApp(
    const ProviderScope(
      child: App(),
    ),
  );
}

==== FILE: router.dart ====
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';
import 'package:nottaalternative/core/authentication/auth_provider.dart';
import 'package:nottaalternative/core/navigation/scaffold_with_navigation.dart';
import 'package:nottaalternative/features/record/record_page.dart';
import 'package:nottaalternative/features/settings/settings_page.dart';
import 'package:nottaalternative/features/signin/signin_page.dart';
import 'package:nottaalternative/features/transcript/transcript_page.dart';
import 'package:nottaalternative/features/transcriptions/detail/transcription_detail_page.dart';
import 'package:nottaalternative/features/transcriptions/transcriptions_page.dart';
import 'package:nottaalternative/utils/progress_hud.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../features/audiosave/audio_list_page.dart';

part 'router.g.dart';

class _Location {
  _Location._();
  static const signin = '/signin';
  // homeとしているが、直接transcriptionsに飛ばす設計でも良い気がするので要検討
  // static const home = '/home';
  static const transcript = '/transcript';
  static const record = '/record';
  // transcriptions/:folderId/:transcriptionIdでアクセスするイメージ
  static const transcriptions = '/transcriptions';
  // この設計の場合、もしかしたら、必ずfolderを経由しなければならなくなる？？
  // static const transcriptionFoloder = ':folderId';
  static const transcriptionDetail = ':transcriptionId';
  // AI要約(余裕があれば実装する)
  // transcriptions/:folderId/:transcriptionId/summaryでアクセスする?
  // static const summary = 'summary';
  static const settings = '/settings';
}

@riverpod
GlobalKey<NavigatorState> rootNavigator(RootNavigatorRef ref) =>
    GlobalKey<NavigatorState>(debugLabel: 'root');

extension GoRouterX on GoRouter {
  NavigatorState get navigator => routerDelegate.navigatorKey.currentState!;
}

@riverpod
GoRouter router(RouterRef ref) {
  return GoRouter(

      routes: $appRoutes,
      debugLogDiagnostics: kDebugMode,
      initialLocation: _Location.transcriptions,
      navigatorKey: ref.watch(rootNavigatorProvider),
      redirect: (context, state) async {
        final signedIn = await ref.watch(isSignedInProvider.future);
        final location = state.uri.toString();
        final isSigninLocation = location == _Location.signin;

        if (!signedIn) {
          return isSigninLocation ? null : _Location.signin;
        }

        if (isSigninLocation) {
          return _Location.transcriptions;
        }

        return null;
      });
}

@TypedGoRoute<SigninPageRoute>(path: _Location.signin)
class SigninPageRoute extends GoRouteData {
  @override
  Widget build(BuildContext context, GoRouterState state) =>
      const _Root(child: SignInPage());
}

@TypedStatefulShellRoute<ShellRouteData>(branches: [
  TypedStatefulShellBranch(
    routes: [
      TypedGoRoute<TranscriptionsPageRoute>(
        path: _Location.transcriptions,
        routes: [
          TypedGoRoute<TranscriptionDetailPageRoute>(
            path: _Location.transcriptionDetail,
          ),
        ],
      ),
    ],
  ),
  TypedStatefulShellBranch(
    routes: [
      TypedGoRoute<TranscriptPageRoute>(
          // 実際に文字起こしを行うのはこのページ
          path: _Location.record),
    ],
  ),
  TypedStatefulShellBranch(
    routes: [
      TypedGoRoute<SettingsPageRoute>(path: _Location.settings),
    ],
  ),
])
class ShellRouteData extends StatefulShellRouteData {
  const ShellRouteData();

  @override
  Widget builder(
    BuildContext context,
    GoRouterState state,
    StatefulNavigationShell navigationShell,
  ) {
    return _Root(
      child: ScaffoldWithNavigation(
        navigationShell: navigationShell,
      ),
    );
  }
}

class _Root extends StatelessWidget {
  const _Root({required this.child});
  final Widget child;

  @override
  Widget build(BuildContext context) {
    return ProgressHUD(child: child);
  }
}

class TranscriptionsPageRoute extends GoRouteData {
  const TranscriptionsPageRoute();

  @override
  Widget build(BuildContext context, GoRouterState state) {
    // TODO: implement build
    return const AudioListPage();
  }
}

class TranscriptionDetailPageRoute extends GoRouteData {
  const TranscriptionDetailPageRoute({required this.transcriptionId});

  final String transcriptionId;

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const TranscriptionDetailPage();
  }
}

class TranscriptPageRoute extends GoRouteData {
  const TranscriptPageRoute();

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const RecordPage();
  }
}

class SettingsPageRoute extends GoRouteData {
  const SettingsPageRoute();

  @override
  Widget build(BuildContext context, GoRouterState state) {
    return const SettingsPage();
  }
}

==== FILE: router.g.dart ====
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'router.dart';

// **************************************************************************
// GoRouterGenerator
// **************************************************************************

List<RouteBase> get $appRoutes => [
      $signinPageRoute,
      $shellRouteData,
    ];

RouteBase get $signinPageRoute => GoRouteData.$route(
      path: '/signin',
      factory: $SigninPageRouteExtension._fromState,
    );

extension $SigninPageRouteExtension on SigninPageRoute {
  static SigninPageRoute _fromState(GoRouterState state) => SigninPageRoute();

  String get location => GoRouteData.$location(
        '/signin',
      );

  void go(BuildContext context) => context.go(location);

  Future<T?> push<T>(BuildContext context) => context.push<T>(location);

  void pushReplacement(BuildContext context) =>
      context.pushReplacement(location);

  void replace(BuildContext context) => context.replace(location);
}

RouteBase get $shellRouteData => StatefulShellRouteData.$route(
      factory: $ShellRouteDataExtension._fromState,
      branches: [
        StatefulShellBranchData.$branch(
          routes: [
            GoRouteData.$route(
              path: '/transcriptions',
              factory: $TranscriptionsPageRouteExtension._fromState,
              routes: [
                GoRouteData.$route(
                  path: ':transcriptionId',
                  factory: $TranscriptionDetailPageRouteExtension._fromState,
                ),
              ],
            ),
          ],
        ),
        StatefulShellBranchData.$branch(
          routes: [
            GoRouteData.$route(
              path: '/record',
              factory: $TranscriptPageRouteExtension._fromState,
            ),
          ],
        ),
        StatefulShellBranchData.$branch(
          routes: [
            GoRouteData.$route(
              path: '/settings',
              factory: $SettingsPageRouteExtension._fromState,
            ),
          ],
        ),
      ],
    );

extension $ShellRouteDataExtension on ShellRouteData {
  static ShellRouteData _fromState(GoRouterState state) =>
      const ShellRouteData();
}

extension $TranscriptionsPageRouteExtension on TranscriptionsPageRoute {
  static TranscriptionsPageRoute _fromState(GoRouterState state) =>
      const TranscriptionsPageRoute();

  String get location => GoRouteData.$location(
        '/transcriptions',
      );

  void go(BuildContext context) => context.go(location);

  Future<T?> push<T>(BuildContext context) => context.push<T>(location);

  void pushReplacement(BuildContext context) =>
      context.pushReplacement(location);

  void replace(BuildContext context) => context.replace(location);
}

extension $TranscriptionDetailPageRouteExtension
    on TranscriptionDetailPageRoute {
  static TranscriptionDetailPageRoute _fromState(GoRouterState state) =>
      TranscriptionDetailPageRoute(
        transcriptionId: state.pathParameters['transcriptionId']!,
      );

  String get location => GoRouteData.$location(
        '/transcriptions/${Uri.encodeComponent(transcriptionId)}',
      );

  void go(BuildContext context) => context.go(location);

  Future<T?> push<T>(BuildContext context) => context.push<T>(location);

  void pushReplacement(BuildContext context) =>
      context.pushReplacement(location);

  void replace(BuildContext context) => context.replace(location);
}

extension $TranscriptPageRouteExtension on TranscriptPageRoute {
  static TranscriptPageRoute _fromState(GoRouterState state) =>
      const TranscriptPageRoute();

  String get location => GoRouteData.$location(
        '/record',
      );

  void go(BuildContext context) => context.go(location);

  Future<T?> push<T>(BuildContext context) => context.push<T>(location);

  void pushReplacement(BuildContext context) =>
      context.pushReplacement(location);

  void replace(BuildContext context) => context.replace(location);
}

extension $SettingsPageRouteExtension on SettingsPageRoute {
  static SettingsPageRoute _fromState(GoRouterState state) =>
      const SettingsPageRoute();

  String get location => GoRouteData.$location(
        '/settings',
      );

  void go(BuildContext context) => context.go(location);

  Future<T?> push<T>(BuildContext context) => context.push<T>(location);

  void pushReplacement(BuildContext context) =>
      context.pushReplacement(location);

  void replace(BuildContext context) => context.replace(location);
}

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$rootNavigatorHash() => r'bf3a55396e6c7a536bad5970f01cdf155352c0db';

/// See also [rootNavigator].
@ProviderFor(rootNavigator)
final rootNavigatorProvider =
    AutoDisposeProvider<GlobalKey<NavigatorState>>.internal(
  rootNavigator,
  name: r'rootNavigatorProvider',
  debugGetCreateSourceHash: const bool.fromEnvironment('dart.vm.product')
      ? null
      : _$rootNavigatorHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef RootNavigatorRef = AutoDisposeProviderRef<GlobalKey<NavigatorState>>;
String _$routerHash() => r'80e86d6e17358fbe15892a7ddec616082881f102';

/// See also [router].
@ProviderFor(router)
final routerProvider = AutoDisposeProvider<GoRouter>.internal(
  router,
  name: r'routerProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$routerHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

typedef RouterRef = AutoDisposeProviderRef<GoRouter>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member

